type: object
title: Elastigroup Strategy
properties:
  risk:
    type: integer
    minimum: 0
    maximum: 100
    example: 100
    default: 0
    description: >
      The percentage of Elastigroup that will run with spot market capacity
  onDemandCount:
    type: integer
    minimum: 0
    example: 0
    description: >
      Minimum number of instances that will always be on-demand
  availabilityVsCost:
    type: string
    enum:
      - availabilityOriented
        equalAzDistribution
        costOriented
        cheapest
        balanced
    default: balanced
    description: >
      How Elastigroup determines which instances to add and replace
  drainingTimeout:
    type: integer
    example: 120
    description: >
      The time in seconds to allow the instance be drained from incoming TCP connections and detached from ELB before terminating it, during a scale down operation
  fallbackToOd:
    type: boolean
    default: false
    example: true
    description: >
      When set to `true` Elastigroup will launch On Demand instances if no spot market is available
  scalingStrategy:
    type: object
  lifetimePeriod:
    type: string
    example: days
  revertToSpot:
    type: object
    title: When Elastigroup moves from OnDemand back to Spot capacity
    properties:
      performAt:
        type: string
        example: always
        enum: [ never, always, timeWindow ]
  persistence:
    type: object

    #       scaling:                 utils.joi.object().keys({
    #         up:     utils.joi.array().items(utils.joi.object().keys({
    #           policyName:        utils.joi.string(),
    #           namespace:         utils.joi.string().required(),
    #           source:            utils.joi.string().valid(constants.SCALING_POLICY_SOURCES).allow(null),
    #           metricName:        utils.joi.string().required(),
    #           dimensions:        utils.joi.array().items(utils.joi.object().keys({
    #             name:  utils.joi.string().required(),
    #             value: utils.joi.string().allow(null)
    #           })).min(1).allow(null),
    #           statistic:         utils.joi.string()
    #                                .default(utils._(constants.AWS_CLOUDWATCH_STATISTICS).where({default: true}).pluck('name').pop())
    #                                .valid(utils._(constants.AWS_CLOUDWATCH_STATISTICS).pluck('name').value()),
    #           extendedStatistic: utils.joi.string().regex(/^p[0-9]{1,3}(\.[0-9]{1,2}$)?/, 'extendedStatistic'),
    #           unit:              utils.joi.string()
    #                                .default(utils._(constants.AWS_CLOUDWATCH_UNITS).where({default: true}).pluck('name').pop())
    #                                .valid(utils._(constants.AWS_CLOUDWATCH_UNITS).pluck('name').value()),
    #           threshold:         utils.joi.number().required(),
    #           adjustment:        utils.joi.number().min(0).allow(null),
    #           minTargetCapacity: utils.joi.number().min(0).allow(null),
    #           period:            utils.joi.number().multiple(60).min(0).default(300),
    #           evaluationPeriods: utils.joi.number().integer().min(1).default(1),
    #           cooldown:          utils.joi.number().multiple(60).min(0).default(300),
    #           action:            utils.joi.object().keys({
    #             type:              utils.joi.string().valid(constants.SCALE_UP_ACTION_TYPE).required(),
    #             adjustment:        utils.joi.allow(null),
    #             minTargetCapacity: utils.joi.allow(null),
    #             target:            utils.joi.allow(null),
    #             minimum:           utils.joi.allow(null),
    #             maximum:           utils.joi.allow(null)
    #           }),
    #           operator:          utils.joi.string().valid(scalingOperators).default(constants.SCALING_OPERATORS.GREATER_THAN_EQUAL.keyword),
    #           isEnabled:         utils.joi.boolean().allow(null)
    #         }).xor('adjustment', 'minTargetCapacity', 'action')).allow(null),
    #         down:   utils.joi.array().items(utils.joi.object().keys({
    #           policyName:        utils.joi.string(),
    #           namespace:         utils.joi.string().required(),
    #           source:            utils.joi.string().valid(constants.SCALING_POLICY_SOURCES).allow(null),
    #           metricName:        utils.joi.string().required(),
    #           dimensions:        utils.joi.array().items(utils.joi.object().keys({
    #             name:  utils.joi.string().required(),
    #             value: utils.joi.string().allow(null)
    #           })).min(1).allow(null),
    #           statistic:         utils.joi.string()
    #                                .default(utils._(constants.AWS_CLOUDWATCH_STATISTICS).where({default: true}).pluck('name').pop())
    #                                .valid(utils._(constants.AWS_CLOUDWATCH_STATISTICS).pluck('name').value()),
    #           extendedStatistic: utils.joi.string().regex(/^p[0-9]{1,3}(\.[0-9]{1,2}$)?/, 'extendedStatistic'),
    #           unit:              utils.joi.string()
    #                                .default(utils._(constants.AWS_CLOUDWATCH_UNITS).where({default: true}).pluck('name').pop())
    #                                .valid(utils._(constants.AWS_CLOUDWATCH_UNITS).pluck('name').value()),
    #           threshold:         utils.joi.number().required(),
    #           adjustment:        utils.joi.number().min(0).allow(null),
    #           maxTargetCapacity: utils.joi.number().min(0).allow(null),
    #           period:            utils.joi.number().multiple(60).min(0).default(300),
    #           evaluationPeriods: utils.joi.number().integer().min(1).default(1),
    #           cooldown:          utils.joi.number().multiple(60).min(0).default(300),
    #           action:            utils.joi.object().keys({
    #             type:              utils.joi.string().valid(constants.SCALE_DOWN_ACTION_TYPE).required(),
    #             adjustment:        utils.joi.allow(null),
    #             maxTargetCapacity: utils.joi.allow(null),
    #             target:            utils.joi.allow(null),
    #             minimum:           utils.joi.allow(null),
    #             maximum:           utils.joi.allow(null)
    #           }),
    #           operator:          utils.joi.string().valid(scalingOperators).default(constants.SCALING_OPERATORS.LESS_THAN_EQUAL.keyword),
    #           isEnabled:         utils.joi.boolean().allow(null)
    #         }).xor('adjustment', 'maxTargetCapacity', 'action')).allow(null),
    #         target: utils.joi.array().items(utils.joi.object().keys({
    #           policyName: utils.joi.string().required(),
    #           namespace:  utils.joi.string().required(),
    #           source:     utils.joi.string().valid(constants.SCALING_POLICY_SOURCES).allow(null),
    #           metricName: utils.joi.string().required(),
    #           dimensions: utils.joi.array().items(utils.joi.object().keys({
    #             name:  utils.joi.string().required(),
    #             value: utils.joi.string().allow(null)
    #           })).min(1).allow(null),
    #           statistic:  utils.joi.string()
    #                         .default(utils._(constants.AWS_CLOUDWATCH_STATISTICS).where({default: true}).pluck('name').pop())
    #                         .valid(utils._(constants.AWS_CLOUDWATCH_STATISTICS).pluck('name').value()),
    #           unit:       utils.joi.string()
    #                         .default(utils._(constants.AWS_CLOUDWATCH_UNITS).where({default: true}).pluck('name').pop())
    #                         .valid(utils._(constants.AWS_CLOUDWATCH_UNITS).pluck('name').value()),
    #           cooldown:   utils.joi.number().multiple(60).min(0).default(300),
    #           target:     utils.joi.number().required(),
    #           predictive: utils.joi.object().keys({
    #             mode: utils.joi.string().valid(utils._.values(constants.PREDICTIVE_MODE_TYPE)).required()
    #           }).allow(null)
    #         })).allow(null)
    #       }).allow(null),