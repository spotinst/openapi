type: object
title: Elastigroup Third Party Integrations
properties:
  rancher:
    type: object
    title: rancher
    required:
      - version
        accessKey
        secretKey
        masterHost
    properties:          
      version:    
        type: string
        example: 2
        default: 1
        enum: [1,2]
        description: >
          The Rancher major version
      accessKey:
        type: string
        example: DA91999F83BE4F88AB1C
        description: >
          Rancher API AccessKey
      secretKey:
        type: string
        example: zw4KFyBSc7WSAKNyEvyDy5GHXo2QBa1dLXduKAoL
        description: >
          Rancher API SecretKey
      masterHost:
        type: string
        example: my-rancher-host.com
        description: >
          The public FQDN or IP address of the Rancher Master
  mesosphere:       
    type: object
    title: Mesosphere
    required:
      - apiServer
    properties:
      apiServer:
        type: string
        example: 1.2.3.4
  elasticBeanstalk:
    type: object
    title: AWS ElasticBeanstalk
    properties:
      environmentId:
        type: string
        example: 123
        description: >
          Elastic Beanstalk Environment ID.
      deploymentPreferences:
        type: object
        title: Deployment Preferences
        description: >
          All deployment preferences when deploying a Elastic Beanstalk version.
        properties:
          automaticRoll:
            type: boolean
            example: true
            description: >
              Describes whether new instances will automatically replace old instances upon new Elastic Beanstalk version upload.
          batchSizePercentage:
            type: integer
            minimum: 1
            maximum: 100
            example: 20
            description: >
              Indicates in percentage the amount of instances should be replaced in each batch. If set to null it will be a system default.
          gracePeriod:
            type: integer
            example: 180
            description: >
              The amount of time, in seconds, after the instance has launched to starts and check its health. If set to null it will be a system default.
          strategy:
            type: object
            title: Beanstalk Deployment Strategy
            required:
              - action
            properties:
              action:
                type: string
                enum: [REPLACE_SERVER, RESTART_SERVER]
                example: REPLACE_SERVER
                description: >
                  How the application should be replaced during a roll. Either by replacing or restarting the server.
              shouldDrainInstances: 
                type: boolean
                example: true
                default: true
                description: >
                  Whether the instances should be drained during a roll
      managedActions:        
        type: object
        title: Beanstalk Managed Actions
        description: >
          Settings for enable auto platform updates for beanstalk platforms in our Elastigroups.
          Please verify that using managed actions requires the following permission in your Spotinst policy:
          `elasticbeanstalk:ListPlatformVersions`
        properties:
          platformUpdate: 
            type: object
            title: Managed Actions Platform Update
            properties: 
              performAt:
                type: string
                example: timeWindow
                enum: [timeWindow, never]
              timeWindow:
                type: string
                example: Mon:23:50-Tue:00:20
                description: >
                   Required if `preformAt` is set to `timeWindow`.
                   Must be in the format of EEE:hh:mm-EEE:hh:mm (EEE = day in week, e.g Sun/Mon, etc. 
                   Also, the timeWindow value should be between 30-180 minutes
              updateLevel:
                type: string
                enum: [patch, minorAndPatch]
                example: patch
                description: >
                  Enable managed platform updates to apply patch version updates only,
                  or for both minor and patch version updates.
                  Patch version updates provide bug fixes and performance improvements, 
                  and can include minor configuration changes to the on-instance software, 
                  scripts, and configuration options. Minor version updates provide support 
                  for new Elastic Beanstalk features.
              instanceRefreshEnabled:
                type: boolean
                example: true
                description: >
                  Determines whether to refresh (roll) instances even though no platform update was found for them.


    # ecs:              utils.joi.object().keys({
    #   clusterName:    utils.joi.string().required(),
    #   autoScale:      utils.joi.object().keys({
    #     shouldScaleDownNonServiceTasks: utils.joi.boolean().default(false).allow(null),
    #     isEnabled:                      utils.joi.boolean().default(false),
    #     isAutoConfig:                   utils.joi.boolean().default(false),
    #     cooldown:                       utils.joi.number().multiple(60).min(180).default(300).allow(null),
    #     headroom:                       utils.joi.object().keys({
    #       cpuPerUnit:    utils.joi.number().min(0).default(0),
    #       memoryPerUnit: utils.joi.number().min(0).default(0),
    #       numOfUnits:    utils.joi.number().min(0).default(0)
    #     }).allow(null),
    #     attributes:                     utils.joi.array().items(utils.joi.object().keys({
    #       key:   utils.joi.string().required(),
    #       value: utils.joi.string().required()
    #     })).min(1).max(30).unique().allow(null),
    #     down:                           utils.joi.object().keys({
    #       evaluationPeriods:      utils.joi.number().integer().min(3).default(5),
    #       maxScaleDownPercentage: utils.joi.number().integer().min(1).max(100).allow(null)
    #     }).allow(null)
    #   }).allow(null),
    #   optimizeImages: utils.joi.object().keys({
    #     performAt:            utils.joi.string().valid(Object.values(constants.MAINTENANCE_WINDOW_TYPE)).required(),
    #     timeWindows:          utils.joi.when(utils.joi.ref('performAt'), {
    #       is:        constants.MAINTENANCE_WINDOW_TYPE.TIME_WINDOW,
    #       then:      utils.joi.array().items(utils.joi.string().regex(TIME_WINDOW_REGEX)).min(1).required(),
    #       otherwise: utils.joi.array().items(utils.joi.string().regex(TIME_WINDOW_REGEX)).min(1).allow(null)
    #     }),
    #     shouldOptimizeEcsAmi: utils.joi.boolean().allow(null)
    #   }).allow(null),
    #   batch:          utils.joi.object().keys({
    #     jobQueueNames: utils.joi.array().items(utils.joi.string()).min(1).allow(null)



    # mlbRuntime:       utils.joi.object().keys({
    #   deploymentId: utils.joi.string().required()


    # kubernetes:       utils.joi.object().keys({
    #   integrationMode:   utils.joi.string()
    #                         .valid(utils._(constants.KUBERNETES_INTEGRATION_MODE).pluck('name').value())
    #                         .default(utils._(constants.KUBERNETES_INTEGRATION_MODE).where({default: true}).pluck('name').pop()),
    #   clusterIdentifier: utils.joi.string().when('integrationMode', {
    #     is:   'pod',
    #     then: utils.joi.required()
    #   }),
    #   apiServer:         utils.joi.string().when('integrationMode', {
    #     is:   'saas',
    #     then: utils.joi.required()
    #   }),
    #   token:             utils.joi.string().when('integrationMode', {
    #     is:   'saas',
    #     then: utils.joi.required()
    #   }),
    #   autoScale:         utils.joi.object().keys({
    #     isEnabled:      utils.joi.boolean().default(false),
    #     isAutoConfig:   utils.joi.boolean().default(false),
    #     cooldown:       utils.joi.number().multiple(60).min(180).default(300).allow(null),
    #     headroom:       utils.joi.object().keys({
    #       cpuPerUnit:    utils.joi.number().min(0).default(0),
    #       memoryPerUnit: utils.joi.number().min(0).default(0),
    #       gpuPerUnit:    utils.joi.number().integer().min(0),
    #       numOfUnits:    utils.joi.number().min(0).default(0)
    #     }).allow(null),
    #     resourceLimits: utils.joi.object().keys({
    #       maxVCpu:      utils.joi.number().min(1).allow(null),
    #       maxMemoryGib: utils.joi.number().min(1).allow(null)
    #     }).allow(null),
    #     labels:         utils.joi.array().items(utils.joi.object().keys({
    #       key:   utils.joi.string().required(),
    #       value: utils.joi.string().required()
    #     })).min(1).max(30).unique().allow(null),
    #     down:           utils.joi.object().keys({
    #       evaluationPeriods:      utils.joi.number().integer().min(3).default(5),
    #       maxScaleDownPercentage: utils.joi.number().integer().min(1).max(100).allow(null)
    #     }).allow(null)
    #   }).allow(null)
    # }).xor('clusterIdentifier', 'apiServer').xor('clusterIdentifier', 'token').allow(null),


    # rightScale:       utils.joi.object().keys({
    #   accountId:    utils.joi.string().required(),
    #   refreshToken: utils.joi.string().required(),
    #   region:       utils.joi.string()
    # }).allow(null),
    # opsWorks:         utils.joi.object().keys({
    #   layerId:   utils.joi.string().required(),
    #   stackType: utils.joi.string().valid(constants.OPSWORKS_STACK_TYPE).required()
    # }).allow(null),


    # codeDeploy:       utils.joi.object().keys({
    #   deploymentGroups:           utils.joi.array().items(utils.joi.object().keys({
    #     applicationName:     utils.joi.string().required(),
    #     deploymentGroupName: utils.joi.string().required()
    #   })).min(1).unique().required(),
    #   cleanUpOnFailure:           utils.joi.boolean().required(),
    #   terminateInstanceOnFailure: utils.joi.boolean().required()


    # chef:             utils.joi.object().keys({
    #   chefServer:   utils.joi.string().required(),
    #   organization: utils.joi.string().required(),
    #   user:         utils.joi.string().required(),
    #   pemKey:       utils.joi.string().required(),
    #   chefVersion:  utils.joi.string().required(),


    # nomad:            utils.joi.object().keys({
    #   masterHost: utils.joi.string().required(),
    #   masterPort: utils.joi.number().required(),
    #   aclToken:   utils.joi.string(),
    #   autoScale:  utils.joi.object().keys({
    #     isEnabled:   utils.joi.boolean().default(false),
    #     cooldown:    utils.joi.number().multiple(60).min(180).default(300),
    #     headroom:    utils.joi.object().keys({
    #       cpuPerUnit:    utils.joi.number().min(0).default(0),
    #       memoryPerUnit: utils.joi.number().min(0).default(0),
    #       numOfUnits:    utils.joi.number().min(0).default(0)
    #     }).allow(null),
    #     constraints: utils.joi.array().items(utils.joi.object().keys({
    #       key:   utils.joi.string().regex(NOMAD_CONSTRAINT_KEY_REGEX).required(),
    #       value: utils.joi.string().required()
    #     })).min(1).max(30).unique().allow(null),
    #     down:        utils.joi.object().keys({
    #       evaluationPeriods: utils.joi.number().integer().min(3).default(5)
    #     }).allow(null)
    #   }).allow(null)


    # dockerSwarm:      utils.joi.object().keys({
    #   masterHost: utils.joi.string().required(),
    #   masterPort: utils.joi.number().required(),
    #   autoScale:  utils.joi.object().keys({
    #     isEnabled: utils.joi.boolean().default(false),
    #     cooldown:  utils.joi.number().multiple(60).min(180).default(300),
    #     headroom:  utils.joi.object().keys({
    #       cpuPerUnit:    utils.joi.number().min(0).default(0),
    #       memoryPerUnit: utils.joi.number().min(0).default(0),
    #       numOfUnits:    utils.joi.number().min(0).default(0)
    #     }).allow(null),
    #     labels:         utils.joi.array().items(utils.joi.object().keys({
    #         key:   utils.joi.string().required(),
    #         value: utils.joi.string().required()
    #     })).min(1).max(30).unique().allow(null),
    #     down:      utils.joi.object().keys({
    #       evaluationPeriods: utils.joi.number().integer().min(3).default(5)
    #     }).allow(null)
    #   }).allow(null),
    #   tlsConfig:  utils.joi.object().keys({
    #     tlsEnabled: utils.joi.boolean().required(),
    #     certificate:  utils.joi.string().required(),
    #     privateKey:  utils.joi.string().required()
    #   }).allow(null)


    # route53:          utils.joi.object().keys({
    #   domains: utils.joi.array().items(utils.joi.object().keys({
    #     hostedZoneId:      utils.joi.string().required(),
    #     spotinstAccountId: utils.joi.string().allow(null),
    #     recordSets:        utils.joi.array().items(utils.joi.object().keys({
    #       name:        utils.joi.string().required(),
    #       usePublicIp: utils.joi.boolean().default(false)
    #     })).min(1).unique().required()
    #   })).min(1).unique().required()


    # gitlab:           utils.joi.object().keys({
    #   runner: utils.joi.object().keys({
    #     isEnabled: utils.joi.boolean().allow(null)

